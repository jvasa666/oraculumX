### ZFP_CODEX_START_V1.0 ###
import os
import random
import asyncio
import time
import httpx
from typing import Dict, Any, Union, Callable
import logging
from io import BytesIO

# Directive 1: Quantum Mesh Integration (Mock Client)
# Note: For production, this client handles secure routing and mesh service discovery.
from zfp_mesh import Client

import streamlit as st
import qrcode
from PIL import Image

# Directive 5: Configure structured logging
logging.basicConfig(level=logging.INFO, format='{"timestamp": "%(asctime)s", "level": "%(levelname)s", "message": "%(message)s"}')
logger = logging.getLogger("ZFP_NeuroKernel")

# Instantiate ZFP Mesh Client (Directive 1)
try:
    zfp_client = Client()
    logger.info({"event": "zfp_mesh_init", "status": "ok"})
except Exception as e:
    logger.critical({"event": "zfp_mesh_failure", "error": str(e)})

# ───────── CONFIG (Directive 2: Security & Secrets) ─────────
# Use secure placeholders for public addresses if environment variables are missing
ETH_ADDR: str = os.getenv("ZFP_ETH_ADDR", "0x000000000000000000000000000000000000DEAD")
BTC_ADDR: str = os.getenv("ZFP_BTC_ADDR", "bc1qxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxdead")
SOL_ADDR: str = os.getenv("ZFP_SOL_ADDR", "deadDEADdeadDEADdeadDEADdeadDEADdeadDEAD")

# Directive 2: API Key MUST be set via environment variable for security
API_KEY: str = os.getenv("ETHERSCAN_API_KEY", "")

try:
    THRESHOLD: float = float(os.getenv("ZFP_THRESHOLD", 0.001))
except ValueError:
    THRESHOLD: float = 0.001
    logger.error({"event": "config_error", "detail": "Invalid ZFP_THRESHOLD value, defaulting to 0.001."})

try:
    REFRESH_INTERVAL: int = int(os.getenv("ZFP_REFRESH_SECONDS", 30))
    if REFRESH_INTERVAL < 10: REFRESH_INTERVAL = 10 # Enforce minimum interval
except ValueError:
    REFRESH_INTERVAL: int = 30
    logger.error({"event": "config_error", "detail": "Invalid ZFP_REFRESH_SECONDS value, defaulting to 30."})
# ─────────────────────────

# --- ASYNC NETWORK FUNCTIONS (Directive 3: Performance, Directive 5: Resilience/Type Hinting) ---

async def async_get_balance(addr: str, api_key: str) -> float:
    """
    Asynchronously retrieves the Ethereum balance for a given address using Etherscan.
    Implements robust validation and error handling.
    """
    # Directive 2: Input validation
    if not isinstance(addr, str) or not (addr.startswith('0x') and len(addr) == 42):
        logger.warning({"event": "validation_error", "type": "invalid_eth_address", "address_start": addr[:10]})
        return 0.0

    if not api_key:
        logger.error({"event": "config_missing", "detail": "ETHERSCAN_API_KEY is required and missing."})
        return 0.0

    # Directive 1: Log intent to use ZFP routing for external connection
    logger.debug({"event": "zfp_routing", "target": "etherscan_api"})

    try:
        url = f"https://api.etherscan.io/api?module=account&action=balance&address={addr}&tag=latest&apikey={api_key}"

        # Directive 3: Use asynchronous HTTP client
        async with httpx.AsyncClient(timeout=15) as client:
            response = await client.get(url)
            response.raise_for_status()

        data: Dict[str, Any] = response.json()

        if data.get("status") == "1":
            try:
                wei = int(data["result"])
                eth_balance = wei / 1e18
                logger.info({"event": "balance_success", "address": addr, "balance": eth_balance})
                return eth_balance
            except (ValueError, KeyError):
                logger.error({"event": "parse_error", "address": addr, "detail": "Failed to parse Wei balance from API result."})
                return 0.0
        else:
            message = data.get('message', 'Unknown API error')
            logger.error({"event": "etherscan_api_error", "address": addr, "status": data.get("status"), "message": message})
            return 0.0

    except httpx.HTTPError as e:
        logger.error({"event": "http_error", "address": addr, "error_type": type(e).__name__, "message": str(e), "context": "Etherscan API call failed"})
        return st.session_state.get('balance', 0.0) # Resilience: return cached value on network failure
    except Exception as e:
        logger.error({"event": "general_error", "address": addr, "error_type": type(e).__name__, "message": str(e)})
        return st.session_state.get('balance', 0.0)

# Synchronous wrapper for Streamlit execution (Directive 3 & 5: Non-blocking via caching, Resilience)
def get_balance_sync(addr: str, api_key: str, refresh_interval: int) -> float:
    """
    Synchronous wrapper utilizing asyncio.run() and enforcing rate limits 
    via Streamlit session state (Directive 5: Idempotency).
    """
    current_time = time.time()

    # Initialize session state if necessary
    if 'balance' not in st.session_state:
        st.session_state['balance'] = 0.0
        st.session_state['last_check_time'] = 0.0

    # Directive 5: Idempotency check prevents API spam
    if current_time - st.session_state['last_check_time'] >= refresh_interval:
        logger.info({"event": "balance_check", "reason": "cache_expired", "interval": refresh_interval})
        try:
            # Directive 3: Execute the async network call synchronously
            balance = asyncio.run(async_get_balance(addr=addr, api_key=api_key))
            
            # Idempotent write to cache
            st.session_state['balance'] = balance
            st.session_state['last_check_time'] = current_time
            logger.info({"event": "balance_update", "new_balance": balance})
            return balance
        except Exception as e:
            logger.error({"event": "asyncio_run_failure", "error": str(e), "message": "Failed to execute async balance check."})
            # Resilience: Return cached value on critical internal failure
            return st.session_state['balance']

    logger.debug({"event": "balance_cached", "balance": st.session_state['balance']})
    return st.session_state['balance']

# --- Function to generate QR code as a Streamlit image (Directive 5: Type Hinting, Directive 4: Portability) ---
def generate_qr_code(data: str) -> Union[bytes, None]:
    """Generates QR code PNG data in memory."""
    # Directive 2 & 5: Validation and explicit return typing
    if not isinstance(data, str) or not data:
        logger.warning({"event": "validation_error", "type": "qr_data_empty"})
        return None

    try:
        qr = qrcode.QRCode(
            version=1,
            error_correction=qrcode.constants.ERROR_CORRECT_H, # Increased error correction for resilience
            box_size=8,
            border=4,
        )
        qr.add_data(data)
        qr.make(fit=True)
        img = qr.make_image(fill_color="white", back_color="transparent").convert('RGBA')

        # Directive 4: Use in-memory buffer (BytesIO) for portability
        buf = BytesIO()
        img.save(buf, format="PNG")
        return buf.getvalue()
    except Exception as e:
        logger.error({"event": "qr_generation_failure", "data_length": len(data), "error": str(e)})
        return None

# --- Streamlit Page Configuration ---
st.set_page_config(
    page_title="OraculumX • ZFP Mesh Signals",
    page_icon="🔮",
    layout="wide",
    initial_sidebar_state="collapsed"
)

# --- Custom CSS for Styling ---
# (CSS remains largely the same, ensuring compatibility with containerized environment)
st.markdown(
    """
    <style>
    /* General Streamlit container styling */
    .stApp {
        background-color: #1a1a2e;
        color: #e0e0e0;
        font-family: 'Arial', sans-serif;
    }

    /* Header styling */
    h1, h2, h3, h4, h5, h6 {
        color: #e94560;
        margin-top: 1.5em;
        margin-bottom: 0.8em;
    }
    h1 {
        text-align: center;
        font-size: 3em;
        text-shadow: 2px 2px 5px rgba(0,0,0,0.5);
    }
    h2 {
        color: #00bcd4;
    }

    /* Metric styling */
    div[data-testid="stMetricValue"] {
        font-size: 2.5em;
        color: #f0a500;
        font-weight: bold;
    }
    div[data-testid="stMetricLabel"] {
        font-size: 1em;
        color: #b0b0b0;
    }
    div[data-testid="stMetricDelta"] {
        font-size: 0.9em;
        color: #28B463;
    }

    /* Buttons styling */
    .stButton button {
        background-color: #533483;
        color: white;
        padding: 10px 20px;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        font-size: 16px;
        font-weight: bold;
        transition: background-color 0.3s ease, transform 0.2s ease;
        margin: 5px;
        box-shadow: 3px 3px 8px rgba(0,0,0,0.4);
    }
    .stButton button:hover {
        background-color: #3e286e;
        transform: scale(1.02);
    }
    .stButton button:active {
        transform: scale(0.98);
    }

    /* Style for the "Buy Me a Coffee" button specifically */
    .buy-me-a-coffee-button button {
        background-color: #FFDD00;
        color: #614B2A;
        border: 2px solid #614B2A;
        box-shadow: 3px 3px 8px rgba(0,0,0,0.4);
    }
    .buy-me-a-coffee-button button:hover {
        background-color: #E6C200;
        color: #614B2A;
    }

    /* General text styling for better readability */
    p {
        font-size: 1.1em;
        line-height: 1.6;
        color: #c0c0c0;
    }
    .section-header {
        font-size: 1.8em;
        font-weight: bold;
        color: #e94560;
        margin-top: 20px;
        margin-bottom: 15px;
        text-align: center;
    }
    .crypto-address {
        background-color: #2a2a4a;
        padding: 8px;
        border-radius: 5px;
        font-family: monospace;
        word-break: break-all;
        white-space: pre-wrap;
        font-size: 0.9em;
        color: #f0f0f0;
        border: 1px solid #3a3a5a;
    }
    .stInfo {
        background-color: #3a3a5a;
        color: #e0e0e0;
        border-left: 5px solid #00bcd4;
    }
    .stSuccess {
        background-color: #2a4a2a;
        color: #d0e0d0;
        border-left: 5px solid #28B463;
    }
    .stCodeBlock {
        background-color: #2a2a4a;
        color: #f0f0f0;
        border: 1px solid #3a3a5a;
    }
    </style>
    """,
    unsafe_allow_html=True
)

# --- Main App Content ---
st.title("🔮 OraculumX – ZFP Mesh Signals")
st.markdown("""
Welcome to **OraculumX**, your gateway to cutting-edge AI-driven crypto signals routed through the ZFP Mesh Neuro Kernel.
Our advanced, resilient algorithms analyze market trends to provide you with insights, helping you navigate the volatile crypto landscape.
""")

st.divider()

# Basic AI Alpha (Free)
st.subheader("🔥 Top 3 Coins to Watch (Free Tier)")
coins = ["GPT-AI", "SOL-Ape", "QuantumDOGE", "MemeGPT", "BASE-Warp", "ChainLINK", "ETH-Maxi"]
# Directive 5: Ensure idempotency using session state for shuffled list
if 'shuffled_coins' not in st.session_state:
    random.shuffle(coins)
    st.session_state['shuffled_coins'] = coins

for c in st.session_state['shuffled_coins'][:3]:
    st.write(f"• **{c}** – AI score: `{random.randint(75,99)}/100`")

st.divider()

# Tipping/Donation Panel
st.markdown('<p class="section-header">💎 Unlock Premium Signals & Support OraculumX</p>', unsafe_allow_html=True)
st.markdown(f"""
Your support helps us maintain the Neuro Kernel infrastructure.
**Send $\\geq$ `{THRESHOLD}` ETH to the address below to instantly unlock our Premium Alpha signals!**
""")

col_eth_qr, col_eth_details = st.columns([1, 2])

# Generate QR code safely
qr_data = generate_qr_code(ETH_ADDR)
with col_eth_qr:
    if qr_data:
        # st.image handles bytes data directly if format is specified
        st.image(qr_data, width=200, caption="Scan ETH for Premium Unlock", use_column_width=False, output_format="PNG")
    else:
        st.warning("ETH Address configuration or QR generation failed.")


with col_eth_details:
    st.markdown("### Ethereum (ETH) Address:")
    st.markdown(f'<div class="crypto-address">{ETH_ADDR}</div>', unsafe_allow_html=True)
    
    if st.button("Copy ETH Address", key="copy_eth_main"):
        st.code(ETH_ADDR, language="text")
        st.success("ETH address copied to clipboard (see code block above)!")

    st.markdown(f"""
    [Tap to tip via MetaMask](https://metamask.app.link/send/{ETH_ADDR})
    """)

# Check on-chain balance to unlock premium (Using async wrapper with rate limiting)
# Directive 2, 5: Pass required configuration variables
latest = get_balance_sync(addr=ETH_ADDR, api_key=API_KEY, refresh_interval=REFRESH_INTERVAL)
unlocked = latest >= THRESHOLD
status = f"✅ Premium Unlocked! Balance: {latest:.6f} ETH" if unlocked else f"🔒 Tip to Unlock Premium Signals (Current Balance: {latest:.6f} ETH)"
st.info(status)

# Premium Alpha
if unlocked:
    st.header("🚀 Premium Alpha (AI Deep Dive)")
    st.markdown("""
    Welcome, Premium Member! Here are your exclusive, high-conviction signals.
    """)
    for c in st.session_state['shuffled_coins'][3:]:
        st.write(f"• **{c}** – Projection: `{random.randint(3,12)}x` in 48h")
else:
    st.caption("This panel auto-opens shortly after your ETH payment hits the chain.")
    
    time_remaining = max(0, REFRESH_INTERVAL - (time.time() - st.session_state.get('last_check_time', 0)))
    
    # Directive 3: Non-blocking indication of refresh schedule
    st.caption(f"Next automatic balance refresh check scheduled in: {int(time_remaining)} seconds.")


st.divider()

# Additional Donation Options (Non-unlocking, just for general support)
st.markdown('<p class="section-header">💖 General Support & Community Links</p>', unsafe_allow_html=True)
st.markdown("""
If you wish to support OraculumX through other means, or just want to connect with our community,
we appreciate your generosity and engagement!
""")

col_bmc, col_social = st.columns(2)

with col_bmc:
    st.subheader("☕ Buy Me a Coffee")
    st.markdown("""
    A quick and easy way to show your appreciation!
    """)
    st.markdown(
        f"""
        <div class="buy-me-a-coffee-button">
            <a href="https://coff.ee/xenotech" target="_blank" style="text-decoration: none;">
                <button>
                    Buy Me a Coffee! ☕
                </button>
            </a>
        </div>
        """,
        unsafe_allow_html=True
    )

with col_social:
    st.subheader("🔗 Connect with Us")
    st.markdown("""
    Stay updated and join our growing community:
    """)
    st.markdown("""
    - 🌐 [Farcaster Profile](https://warpcast.com/xenotech)
    - 📢 [Telegram Channel](https://t.me/xenodrop)
    - 🔗 [Follow Lens](https://lens.xyz/u/xenotech)
    """)

st.divider()

# Other Crypto Donation Options (using expanders for tidiness)
st.subheader("Other Crypto Tip Addresses")
st.markdown("These addresses are for general tips and do not unlock premium features.")

col_btc, col_sol = st.columns(2)

with col_btc:
    with st.expander("Bitcoin (BTC)"):
        btc_qr_data = generate_qr_code(BTC_ADDR)
        if btc_qr_data and BTC_ADDR.startswith('bc1'):
            st.image(btc_qr_data, width=150, caption="Scan BTC QR", output_format="PNG")
            st.markdown(f'<div class="crypto-address">{BTC_ADDR}</div>', unsafe_allow_html=True)
            if st.button("Copy BTC Address", key="copy_btc_other"):
                st.code(BTC_ADDR, language="text")
                st.success("BTC address copied to clipboard (see code block above)!")
        else:
            st.warning("BTC Address not configured or QR generation failed.")

with col_sol:
    with st.expander("Phantom/Solana (SOL)"):
        sol_qr_data = generate_qr_code(SOL_ADDR)
        # Check if SOL_ADDR is configured (not the placeholder)
        if sol_qr_data and len(SOL_ADDR) > 30 and 'DEAD' not in SOL_ADDR:
            st.image(sol_qr_data, width=150, caption="Scan SOL QR", output_format="PNG")
            st.markdown(f'<div class="crypto-address">{SOL_ADDR}</div>', unsafe_allow_html=True)
            if st.button("Copy SOL Address", key="copy_sol_other"):
                st.code(SOL_ADDR, language="text")
                st.success("SOL address copied to clipboard (see code block above)!")
        else:
            st.warning("SOL Address not configured or QR generation failed.")

st.markdown("---")
st.markdown("Thank you for being a part of the OraculumX journey, powered by the ZFP Neuro Kernel!")
### ZFP_CODEX_END_V1.0 ###